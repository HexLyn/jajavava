package LeetCode;

import java.util.*;

public class Solution4 {
    public int solution(int[] d, int budget) {
        int answer = 0;

//        예산 요청안의 오름차순 정렬.
//        +)byte, char, int, long같은 Primitive배열엔 내림차순 못함
        Arrays.sort(d);

//        예산안이 0 미만이 될때까지 시행.
            for(int i = 0; i < d.length; i++) {
                if(budget >= d[i]) {
                    budget -= d[i];
                    answer++;
                } else {
                    break;
                }
            }
        return answer;
    }
}

//한정된 예산. 최대한 많은 부서의 물품을 구매한다.
//물품 구매 시 각 부서가 신청한 금액만큼을 모두 지원.
//1,000원 신청 시 정확히 1,000지원, 더 적게, 많이는 불가능.
//부서 별 신청 예산 배열 d, 예산 budget 주어짐.
//이 때 최대 몇개의 부서에 지원가능한 지 리턴.

//d = [1,3,2,5,4] , budget=9일 때, result는 3.
//본 예에서는 최대한 많은 부서 지원 할 시, 최대 3개 부서까지 가능. 그래서 3리턴.

// 1. 때려박기
// 모든 조합(combine)에서의 합을 구한다.
// 해당 조합 중 (combine <= budget) 이면서 최대값(max)인걸 찾아낸다.
// 해당 최대값의 배열 길이를 리턴 => 최대 몇개 부서에 가능한지 도출.
// 본 문제에서 - `d`의 크기는 $1$ 이상 $100$ 이하
//- `d`의 각 부서별 신청 금액은 $1$ 이상 $10^5$ 이하
//- `budget`은 $1$ 이상 $10^7$ 이하 즉, 때려박으면 절대 안됨.

//2. d를 오름차순 정렬 후 계산.
// 가장 많은 부서에 지원하려면 결국 요청금액이 적은 부서들만으로 구성해야 함.
// 오름차순으로 정렬 시, 예산 편성안에서 한 부서를 더 추가할 경우 값은 무조건
// 크거나 같은 수준, 즉 예산안이 적은 부서부터 전체 예산이 전부 소모될 때 까지
// 예산을 배정하면 해결.